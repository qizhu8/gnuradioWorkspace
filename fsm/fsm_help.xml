<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
          "docbookx.dtd" [
]>

<article>

<articleinfo>
  <title>A Finte State Machine (FSM) Specification Class</title>
  <author>
     <firstname>Achilleas</firstname>
     <surname>Anastasopoulos</surname>
     <affiliation>
        <address>
           <email>anastas@umich.edu</email>
        </address>
     </affiliation>
  </author>

<!--
<revhistory>
  <revision>
  <revnumber>v0.0</revnumber>
  <date>2006-08-03</date>
  <revremark>
    First cut.
  </revremark>
  </revision>
</revhistory>
-->

<abstract><para>This document provides a description of the
Finite State Machine (FSM) implementation 
</para></abstract>

</articleinfo>




<!--=====================================================-->
<sect1 id="intro"><title>Introduction</title>

<para>
The basic goal of the implementation is to have a generic way of
describing an FSM that is decoupled from whether it describes a
convolutional
code (CC), a trellis code (TC), an inter-symbol interference (ISI)
channel, or any
other communication system that can be modeled with an FSM.
To achieve this goal, we need to separate the pure FSM descrition from the
rest of the model details. For instance, in the case of a rate 2/3 TC,
the FSM should not involve details about the modulation used (it can
be an 8-ary PAM, or 8-PSK, etc). Similarly, when attempting maximum likelihood
sequence detection (MLSD)--using for instance the Viterbi algorithm (VA)--
the VA implementation should not be concerned with the channel details
(such as modulations, channel type, hard or soft inputs, etc).
Clearly, having generality as the primary goal implies some penalty
on the code efficiency, as compared to fully custom implementations.
</para>

<para>
We will now describe the implementation of the basic ingedient, the FSM.
</para>

</sect1>


<!--=====================================================-->
<sect1 id="fsm"><title>The FSM class</title>

<para>An FSM describes the evolution of a system with inputs
x<subscript>k</subscript>, states s<subscript>k</subscript> and outputs y<subscript>k</subscript>. At time k the FSM state is s<subscript>k</subscript>.
Upon reception of a new input symbol x<subscript>k</subscript>, it outputs an output symbol
y<subscript>k</subscript> which is a function of both x<subscript>k</subscript> and s<subscript>k</subscript>.
It will then move to a next state s<subscript>k+1</subscript>.
An FSM has a finite number of states, input and output symbols.
All these are formally described as follows:
</para>

<itemizedlist>
<listitem><para>The input alphabet A<subscript>I</subscript>={0,1,2,...,I-1}, with cardinality I, so that x<subscript>k</subscript> takes values in A<subscript>I</subscript>.</para></listitem>
<listitem><para>The state alphabet A<subscript>S</subscript>={0,1,2,...,S-1}, with cardinality S, so that s<subscript>k</subscript> takes values in A<subscript>S</subscript>.</para></listitem>
<listitem><para>The output alphabet A<subscript>O</subscript>={0,1,2,...,O-1}, with cardinality O, so that y<subscript>k</subscript> takes values in A<subscript>O</subscript></para></listitem>
<listitem><para>The "next-state" function NS: A<subscript>S</subscript> x A<subscript>I</subscript> --> A<subscript>S</subscript>,
with the meaning
s<subscript>k+1</subscript> = NS(s<subscript>k</subscript>, x<subscript>k</subscript>)</para></listitem>
<listitem><para>The "output-symbol" function OS: A<subscript>S</subscript> x A<subscript>I</subscript> --> A<subscript>S</subscript>,
with the meaning
y<subscript>k</subscript> = OS(s<subscript>k</subscript>, x<subscript>k</subscript>)</para></listitem>
</itemizedlist>

<para>
Thus, a complete description of the FSM is given by the
the five-tuple (I,S,O,NS,OS).
Observe that implementation details are hidden
in how the outside world interprets these input and output
integer symbols.
Here is an example of an FSM describing the (2,1) CC
with constraint length 3 and generator polynomial matrix
(1+D+D<superscript>2</superscript> ,  1+D<superscript>2</superscript>)
from Proakis-Salehi pg. 779.
</para>


<example id="cc_ex"><title>(2,1) CC with generator polynomials (1+D+D<superscript>2</superscript> , 1+D<superscript>2</superscript>)</title>

<para>
This CC accepts 1 bit at a time, and outputs 2 bits at a time.
It has a shift register storing the last two input bits.
In particular,
b<subscript>k</subscript>(0)=x<subscript>k</subscript>+
x<subscript>k-1</subscript>+x<subscript>k-2</subscript>, and
b<subscript>k</subscript>(1)=x<subscript>k</subscript>+
x<subscript>k-2</subscript>, where addition is mod-2.
We can represent the state of this system
as s<subscript>k</subscript> = (x<subscript>k-1</subscript> x<subscript>k-2</subscript>)<subscript>10</subscript>. In addition we can represent its
output symbol as y<subscript>k</subscript> = (b<subscript>k</subscript>(1) b<subscript>k</subscript>(0))<subscript>10</subscript>.
Based on the above assumptions, the input alphabet A<subscript>I</subscript>={0,1}, so I=2;
the state alphabet A<subscript>S</subscript>={0,1,2,3}, so S=4; and
the output alphabet A<subscript>O</subscript>={0,1,2,3}, so O=4.
The "next-state" function NS(,) is given by
<programlisting>
s<subscript>k</subscript>	x<subscript>k</subscript>	s<subscript>k+1</subscript>
0	0	0
0	1	2
1	0	0
1	1	2
2	0	1
2	1	3
3	0	1
3	1	3
</programlisting>
The "output-symbol" function OS(,) can be given by
<programlisting>
s<subscript>k</subscript>	x<subscript>k</subscript>	y<subscript>k</subscript>
0	0	0
0	1	3
1	0	3
1	1	0
2	0	1
2	1	2
3	0	2
3	1	1
</programlisting>
</para>

<para>
Note that although the CC outputs 2 bits per time period, following
our approach, there is only one (quaternary) output symbol per
time period (for instance, here we use the decimal representation
of the 2-bits). Also note that the modulation used is not part of
the FSM description: it can be BPSK, OOK, BFSK, QPSK with or without Gray mapping, etc;
it is up to the rest of the program to interpret the meaning of
the symbol y<subscript>k</subscript>.
</para>

</example>


<para>
The C++ implementation of the FSM class keeps private information about
I,S,O,NS,OS and public methods to read and write them. The NS
and OS matrices are implemented as STL 1-dimensional vectors.
</para>

<programlisting>
class fsm {
private:
  int d_I;
  int d_S;
  int d_O;
  std::vector&lt;int&gt; d_NS;
  std::vector&lt;int&gt; d_OS;
  std::vector&lt; std::vector&lt; int&gt; &gt; d_PS;
  std::vector&lt; std::vector&lt; int&gt; &gt; d_PI;
  std::vector&lt;int&gt; d_TMi;
  std::vector&lt;int&gt; d_TMl;
  void generate_PS_PI ();
  void generate_TM ();
  bool find_es(int es);
public:
  fsm();
  fsm(const fsm &amp;FSM);
  fsm(int I, int S, int O, const std::vector&lt;int&gt; &amp;NS, const std::vector&lt;int&gt; &amp;OS);
  fsm(const char *name);
  fsm(int k, int n, const std::vector&lt;int&gt; &amp;G);
  fsm(int mod_size, int ch_length);
  int I () const { return d_I; }
  int S () const { return d_S; }
  int O () const { return d_O; }
  const std::vector&lt;int&gt; &amp; NS () const { return d_NS; }
  const std::vector&lt;int&gt; &amp; OS () const { return d_OS; }
  const std::vector&lt; std::vector&lt; int&gt; &gt; &amp; PS () const { return d_PS; }
  const std::vector&lt; std::vector&lt; int&gt; &gt; &amp; PI () const { return d_PI; }
  const std::vector&lt;int&gt; &amp; TMi () const { return d_TMi; }
  const std::vector&lt;int&gt; &amp; TMl () const { return d_TMl; }
};
</programlisting>

<para>
As can be seen, other than the trivial and the copy constructor,
there are three additional
ways to construct an FSM.
</para>

<itemizedlist>
<listitem>
<para>Supplying the parameters I,S,O,NS,OS:</para>
<programlisting>
  fsm(const int I, const int S, const int O, const std::vector&lt;int&gt; &amp;NS, const std::vector&lt;int&gt; &amp;OS);
</programlisting>
</listitem>

<listitem>
<para>Giving a filename containing all the FSM information:</para>
<programlisting>
  fsm(const char *name);
</programlisting>
<para>
This information has to be in the following format:
<programlisting>
I S O

NS(0,0)   NS(0,1)   ...  NS(0,I-1)
NS(1,0)   NS(1,1)   ...  NS(1,I-1)
...
NS(S-1,0) NS(S-1,1) ...  NS(S-1,I-1)

OS(0,0)   OS(0,1)   ...  OS(0,I-1)
OS(1,0)   OS(1,1)   ...  OS(1,I-1)
...
OS(S-1,0) OS(S-1,1) ... OS(S-1,I-1)
</programlisting>
</para>
<para>
For instance, the file containing the information for the example mentioned above is of the form:
<programlisting>
2 4 4

0 2
0 2
1 3
1 3

0 3
3 0
1 2
2 1
</programlisting>
</para>
</listitem>


<listitem>
<para>
The third way is specific to FSMs representing binary (n,k) conolutional codes. These FSMs are specified by the number of input bits k, the number of output bits n, and the generator matrix, which is a k x n matrix of integers
G = [g<subscript>i,j</subscript>]<subscript>i=1:k, j=1:n</subscript>, given as an one-dimensional STL vector.
Each integer g<subscript>i,j</subscript> is the decimal representation of the
polynomial g<subscript>i,j</subscript>(D) (e.g., g<subscript>i,j</subscript>= 6 = 110<subscript>2</subscript> is interpreted as g<subscript>i,j</subscript>(D)=1+D) describing the connections from  the sequence x<subscript>i</subscript> to
y<subscript>j</subscript> (e.g., in the above example y<subscript>j</subscript>(k) = x<subscript>i</subscript>(k) + x<subscript>i</subscript>(k-1)).
</para>
<programlisting>
  fsm(int k, int n, const std::vector&lt;int&gt; &amp;G);
</programlisting>
</listitem>


<listitem>
<para>
The fourth way is specific to FSMs resulting from shift registers, and the output symbol being the entire transition (ie, current_state and current_input). These FSMs are usefull when describibg ISI channels. In particular the state is comprised of the input symbols x(k-1), x(k-2),...,x(k-L), where L = ch_length-1 and each x(i) belongs to an alphabet of size mod_size. The output is taken to be x(k), x(k-1), x(k-2),...,x(k-L) (in decimal format)
</para>
<programlisting>
  fsm(const int mod_size, const int ch_length);
</programlisting>
</listitem>

<listitem>
<para>
I have added other constructors as well, eg, one that constructs an FSM appropriate for modeling an arbitrary CPM scheme; one that constructs the radix-n version of a given FSM; one that constructs the "concatenation" of two FSMs, etc.
</para>
</listitem>




</itemizedlist>


<para>
As can be seen from the above description, there are
two more variables included in the FSM class implementation,
the PS and the PI matrices. These are computed internally
when an FSM is instantiated and their meaning is as follows.
Sometimes (eg, in the traceback operation of the VA) we need
to trace the history of the state or the input sequence.
To do this we would like to know for a given state s<subscript>k</subscript>, what are the possible previous states s<subscript>k-1</subscript>
and what input symbols x<subscript>k-1</subscript> will get us from
s<subscript>k-1</subscript> to s<subscript>k</subscript>. This information can be derived from NS; however we want to have it ready in a
convenient format.
In the following we assume that for any state,
the number of incoming transitions is the same as the number of
outgoing transitions, ie, equal to I. All applications of interest
have FSMs satisfying this requirement.

If we arbitrarily index the incoming transitions to the current state
by "i", then  as i goes from 0 to I-1, PS(s<subscript>k</subscript>,i)
gives all previous states s<subscript>k-1</subscript>,
and PI(s<subscript>k</subscript>,i) gives all previous inputs x<subscript>k-1</subscript>.
In other words, for any given s<subscript>k</subscript> and any index i=0,1,...I-1, starting from
s<subscript>k-1</subscript>=PS(s<subscript>k</subscript>,i)
with input
x<subscript>k-1</subscript>=PI(s<subscript>k</subscript>,i)
will get us to the state s<subscript>k</subscript>.
More formally, for any i=0,1,...I-1 we have
s<subscript>k</subscript> = NS(PS(s<subscript>k</subscript>,i),PI(s<subscript>k</subscript>,i)).

</para>


<para>
Finally, there are
two more variables included in the FSM class implementation,
the TMl and the TMi matrices. These are both S x S matrices (represented as STL vectors) computed internally
when an FSM is instantiated and their meaning is as follows.
TMl(i,j) is the minimum number of trellis steps required to go from state i to state j.
Similarly, TMi(i,j) is the initial input required to get you from state i to state j in the minimum number of steps. As an example, if TMl(1,4)=2, it means that you need 2 steps in the trellis to get from state 1 to state 4. Further,
if TMi(1,4)=0 it means that the first such step will be followed if when at state 1 the input is 0. Furthermore, suppose that NS(1,0)=2. Then, TMl(2,4) should be 1 (ie, one more step is needed when starting from state 2 and having state 4 as the final destination). Finally, TMi(2,4) will give us the second input required to complete the path from 1 to 4.
These matrices are useful when we want to implement an encoder with proper state termination. For instance, based on these matrices we can evaluate how many
additional input symbols (and which particular inputs) are required to be appended at the end of an input sequence so that the final state is always 0.

</para>


</sect1>



</article>
